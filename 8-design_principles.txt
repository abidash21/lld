Design Principle
-To maintain, scalable and easy to understand, to achieve this foundational guideline to achieve this is SOLID Principle
- Scalability: adding new features becomes straight forward
- Maintainability: changes in one part of the system has minimal impact on others
- Testability: Decoupled design makes unit testing stronger
- Readability: Clear separation of concerns improves code comprehensions

SOLID Principles

1. SINGLE RESPONSIBILITY PRINCIPLE
- A class should have only one reason to change

********* bad code *********

class BreadBaker {
 public
  void bakeBread() { System.out.println("Baking high-quality bread..."); }

 public
  void manageInventory() { System.out.println("Managing inventory..."); }

 public
  void orderSupplies() { System.out.println("Ordering supplies..."); }

 public
  void serveCustomer() { System.out.println("Serving customers..."); }

 public
  void cleanBakery() { System.out.println("Cleaning the bakery..."); }

 public
  static void main(String[] args) {
    BreadBaker baker = new BreadBaker();
    baker.bakeBread();
    baker.manageInventory();
    baker.orderSupplies();
    baker.serveCustomer();
    baker.cleanBakery();
  }
}


******** good code *******
class BreadBaker {
    public void bakeBread() {
        System.out.println("Baking high-quality bread...");
    }
}

class InventoryManager {
    public void manageInventory() {
        System.out.println("Managing inventory...");
    }
}

class SupplyOrder {
    public void orderSupplies() {
        System.out.println("Ordering supplies...");
    }
}

class CustomerService {
    public void serveCustomer() {
        System.out.println("Serving customers...");
    }
}

class BakeryCleaner {
    public void cleanBakery() {
        System.out.println("Cleaning the bakery...");
    }
}

public class Bakery {
    public static void main(String[] args) {
        BreadBaker baker = new BreadBaker();
        InventoryManager inventoryManager = new InventoryManager();
        SupplyOrder supplyOrder = new SupplyOrder();
        CustomerService customerService = new CustomerService();
        BakeryCleaner cleaner = new BakeryCleaner();

        baker.bakeBread();
        inventoryManager.manageInventory();
        supplyOrder.orderSupplies();
        customerService.serveCustomer();
        cleaner.cleanBakery();
    }
}

- The code becomes more maintainable
- Easier to understand
- Changes in one class doesn't affect unrelated parts
- Enhances readability and reduces complexity
- Each class has a clear and focused Responsibility
- The system is more modular and easy to manage


2. OPEN CLOSED PRINCIPLE
- Open for extension but closed for modification


********* bad code *********

class Shape {
 private
  String type;
 public
  double calculateArea() {
    if (type.equals("circle")) {
      // Circle area calculation
    } else if (type.equals("rectangle")) {
      // Rectangle area calculation
    }
  }
}


******** good code *******

abstract class Shape {
    abstract double calculateArea();
}

class Circle extends Shape {
    private double radius;

    Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double length;
    private double width;

    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }

    @Override
    public double calculateArea() {
        return length * width;
    }
}

class Triangle extends Shape {
    private double height;
    private double base;

    Triangle(double height, double base) {
        this.height = height;
        this.base = base;
    }

    @Override
    public double calculateArea() {
        return 0.5 * height * base;
    }
}


- Prevents breaking existing code
- Encourages reusable components
- Code is more maintainable
- Adding new shape doesn't require modification in existingcode